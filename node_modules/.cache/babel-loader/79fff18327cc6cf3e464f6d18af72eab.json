{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\timjh\\\\Documents\\\\GitHub\\\\Snowy_Scene\\\\src\\\\App.js\";\nimport './App.css';\nimport * as Tone from 'tone';\nimport React, { useState } from 'react';\nimport * as d3 from 'd3';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Legend from './Legend.jsx';\nimport Cube from './Cube.jsx';\nimport Environment from './Environment.jsx';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  //   var options = {\n  //     note: 'A',\n  //     mode: \"Major\",\n  //     tempo: 90,\n  //     scale: [],\n  //     speed: 0.002,\n  //   };\n  //   const [mode, setMode] = useState(options.mode);\n  //   const [note, setNote] = useState(options.note);\n  //   const [tempo, setTempo] = useState(options.tempo);\n  //   let [scale, setScale] = useState(options.scale);\n  //   let start = false;\n  //   let range = [0,9];\n  //   // Control the current scale we're playing in\n  //   const scaleRef = React.useRef(options.scale);\n  //   // Correctly start the simulation/audio\n  //   const startRef = React.useRef(start);\n  //   // Control the minimum speed of cubes\n  //   const speedRef = React.useRef(options.speed);\n  //   // Control the range of notes available to modify\n  //   const rangeRef = React.useRef(range);\n  //   let numCubes = 6;\n  //   // Define some music theory terms\n  //   // Starting at 'C0' and ending at 'G#9'\n  //   const min = 1;\n  //   const max = 9;\n  //   const midpoint = (max-min)/2;\n  //   const modes = ['Major', 'Minor'];\n  //   const notes = ['A','A#','B','C','C#','D','D#','E','F','F#','G','G#'];\n  //   // W - Whole step\n  //   // H - Half step\n  //   // 'Final' notes are omitted to avoid duplicates i.e. C major ends at B, not C\n  //   // Major scales follow the pattern of W-W-H-W-W-W-H\n  //   const major = [0,2,4,5,7,9,11];\n  //   // Minor scales follow the pattern of W-H-W-W-H-W-W\n  //   const minor = [0,2,3,5,7,8,10]; \n  //   // On change, calculate a new scale with input values\n  //   function appOnChange() {\n  //   options.scale = [];\n  //   let arr = (mode === \"Major\") ? major : minor;\n  //   let start = notes.indexOf(note);\n  //   arr.forEach(function(d) {\n  //     options.scale.push(notes[((d + start) % notes.length)]);\n  //      });\n  //   scaleRef.current = options.scale;\n  // }\n  // async function initAudio() {\n  //   if(startRef.current) {\n  //     startRef.current = startRef.current;\n  //   } else {\n  //   await Tone.start();\n  //   startRef.current = true;\n  //   console.log(\"Audio initialized\");\n  //   }\n  // }\n  const scene = new THREE.Scene();\n  const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);\n  const renderer = new THREE.WebGLRenderer();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  document.body.appendChild(renderer.domElement); // L/W/H of the box - how far does a cube travel before resetting\n\n  const max = 8; // Create standard box geometry\n\n  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);\n  var bb = new THREE.BoxGeometry(max * Math.E, max * Math.E, max * Math.E); // var bb = new THREE.SphereGeometry(max*Math.E*2,max*Math.E,max*Math.E);\n  //var bb = new THREE.SphereGeometry();\n\n  var sphere = new THREE.SphereGeometry(max + 0.25);\n  var object = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    transparent: true,\n    opacity: 0.4\n  }));\n  var box = new THREE.BoxHelper(object);\n  scene.add(box);\n  scene.add(object);\n  const clock = new THREE.Clock(); // Create bounding box render\n\n  const bound = new THREE.BoxHelper(new THREE.Mesh(bb, new THREE.MeshBasicMaterial(0xff0000)), 0xffffff);\n  scene.add(bound);\n  const controls = new OrbitControls(camera, renderer.domElement);\n  camera.position.z = 15;\n  var dx = 0.05;\n  var dy = 0.05;\n  var dz = 0.05; // scale_len = the length of any major or minor scale\n  //var scale_len = props.scaleRef.current.length;\n  //var max_speed = 0.002;\n  // Define base and max speed\n  // Then, generate a scalar up to max to multiply the base by\n\n  var max_mult = 5; //var min_speed = props.speed;\n  // Each note timing can range from 1-256\n  // This can be represented as a random power of 2 as\n  // 2**8 == 256 and 2**0 == 1\n\n  const max_note_len = 8; // What is the maximum pitch notes can play at\n\n  const max_pitch = 4; // What is the minimum pitch notes can play at\n\n  const min_pitch = 2; // Notes can be represented by:\n  // n - regular note\n  // t - triplet\n  // n. - dotted note\n  // e.g. 4n. is a dotted quarter note\n\n  const note_types = ['n', 't'];\n  var cubes = [];\n  const reverb = new Tone.Reverb(2);\n  const delay = new Tone.PingPongDelay(\"8n\", 0.2);\n  const env = new Tone.Envelope(0.4);\n  const vibrato = new Tone.Vibrato();\n  const compressor = new Tone.Compressor(-30, 2);\n  env.attackCurve = 'sine'; //env.triggerAttack();\n  // for(var i = 0; i < props.numCubes; i++) {\n  //   const material = new THREE.MeshBasicMaterial( { \n  //     color: props.color(i) } );\n  //   const cube = new THREE.Mesh( geometry, material );\n  //   cubes[i] = cube;\n  //   // Random note, pitch and length generation\n  //   let randNote = Math.floor(Math.random() * scale_len);\n  //   let randPitch = Math.floor(Math.random() * max_pitch) + min_pitch;\n  //   let randLen = 2 ** Math.floor(Math.random() * max_note_len);\n  //   let type_idx = Math.floor(Math.random() * note_types.length);\n  //   cubes[i].minSpeed = props.speedRef.current;\n  //   cubes[i].note = (props.scaleRef.current[randNote] + randPitch);\n  //   cubes[i].note_len = (randLen + note_types[type_idx]);\n  //   cubes[i].synth = new Tone.MembraneSynth();\n  //   //cubes[i].synth = new Tone.FMSynth();\n  //   //cubes[i].synth = new Tone.Synth();\n  //   //cubes[i].synth.chain(vibrato, reverb, compressor, Tone.Destination);\n  //   cubes[i].synth.chain(compressor, Tone.Destination);\n  //   // Define more random values :)\n  //   // Once the cube's counter reaches an arbitrary maximum, switch notes\n  //   cubes[i].counter = 0;\n  //   // How many times can a note repeat before changing\n  //   //cubes[i].max_repeats = (Math.ceil((Math.random() * 8))+1);\n  //   cubes[i].max_repeats = 6;\n  //   cubes[i].dx = cubes[i].minSpeed * (2**(Math.ceil((Math.random() * max_mult))+1));\n  //   cubes[i].dy = 0;\n  //   cubes[i].dz = 0;\n  //   const center = new THREE.Vector3();\n  //   cubes[i].dist = new THREE.Vector3(cubes[i].dx,cubes[i].dy,cubes[i].dz);\n  //   scene.add(cube);  \n  // }\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"head\", {\n      children: /*#__PURE__*/_jsxDEV(\"title\", {\n        children: \"Snowy Scene\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: /*#__PURE__*/_jsxDEV(Legend // onChange = {appOnChange()}\n      // modes={modes}\n      // mode={mode}\n      // note={note}\n      // setNote={setNote}\n      // notes={notes}\n      // setMode={setMode}\n      // speedRef={speedRef}\n      // rangeRef={rangeRef}\n      // setNote={setNote}\n      // initAudio={initAudio}\n      // startRef={startRef}\n      , {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 242,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true);\n}\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["C:/Users/timjh/Documents/GitHub/Snowy_Scene/src/App.js"],"names":["Tone","React","useState","d3","THREE","OrbitControls","Legend","Cube","Environment","App","scene","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","renderer","WebGLRenderer","setSize","document","body","appendChild","domElement","max","geometry","BoxGeometry","bb","Math","E","sphere","SphereGeometry","object","Mesh","MeshBasicMaterial","color","transparent","opacity","box","BoxHelper","add","clock","Clock","bound","controls","position","z","dx","dy","dz","max_mult","max_note_len","max_pitch","min_pitch","note_types","cubes","reverb","Reverb","delay","PingPongDelay","env","Envelope","vibrato","Vibrato","compressor","Compressor","attackCurve"],"mappings":"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","sourcesContent":["import './App.css';\r\nimport * as Tone from 'tone'\r\nimport React, { useState } from 'react';\r\nimport * as d3 from 'd3';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\r\nimport Legend from './Legend.jsx';\r\nimport Cube from './Cube.jsx';\r\nimport Environment from './Environment.jsx';\r\nfunction App() {\r\n\r\n\r\n//   var options = {\r\n//     note: 'A',\r\n//     mode: \"Major\",\r\n//     tempo: 90,\r\n//     scale: [],\r\n//     speed: 0.002,\r\n//   };\r\n\r\n\r\n//   const [mode, setMode] = useState(options.mode);\r\n//   const [note, setNote] = useState(options.note);\r\n//   const [tempo, setTempo] = useState(options.tempo);\r\n//   let [scale, setScale] = useState(options.scale);\r\n//   let start = false;\r\n//   let range = [0,9];\r\n\r\n//   // Control the current scale we're playing in\r\n//   const scaleRef = React.useRef(options.scale);\r\n//   // Correctly start the simulation/audio\r\n//   const startRef = React.useRef(start);\r\n//   // Control the minimum speed of cubes\r\n//   const speedRef = React.useRef(options.speed);\r\n//   // Control the range of notes available to modify\r\n//   const rangeRef = React.useRef(range);\r\n\r\n\r\n\r\n//   let numCubes = 6;\r\n\r\n//   // Define some music theory terms\r\n//   // Starting at 'C0' and ending at 'G#9'\r\n//   const min = 1;\r\n//   const max = 9;\r\n\r\n//   const midpoint = (max-min)/2;\r\n\r\n//   const modes = ['Major', 'Minor'];\r\n//   const notes = ['A','A#','B','C','C#','D','D#','E','F','F#','G','G#'];\r\n\r\n//   // W - Whole step\r\n//   // H - Half step\r\n//   // 'Final' notes are omitted to avoid duplicates i.e. C major ends at B, not C\r\n\r\n//   // Major scales follow the pattern of W-W-H-W-W-W-H\r\n//   const major = [0,2,4,5,7,9,11];\r\n\r\n//   // Minor scales follow the pattern of W-H-W-W-H-W-W\r\n//   const minor = [0,2,3,5,7,8,10]; \r\n\r\n  \r\n//   // On change, calculate a new scale with input values\r\n//   function appOnChange() {\r\n//   options.scale = [];\r\n//   let arr = (mode === \"Major\") ? major : minor;\r\n//   let start = notes.indexOf(note);\r\n\r\n//   arr.forEach(function(d) {\r\n\r\n//     options.scale.push(notes[((d + start) % notes.length)]);\r\n//      });\r\n\r\n//   scaleRef.current = options.scale;\r\n\r\n// }\r\n\r\n// async function initAudio() {\r\n\r\n//   if(startRef.current) {\r\n//     startRef.current = startRef.current;\r\n//   } else {\r\n//   await Tone.start();\r\n//   startRef.current = true;\r\n//   console.log(\"Audio initialized\");\r\n//   }\r\n// }\r\n\r\n\r\n\r\n  const scene = new THREE.Scene();\r\n  const camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 1000 );\r\n\r\n  const renderer = new THREE.WebGLRenderer();\r\n  renderer.setSize( window.innerWidth, window.innerHeight );\r\n  document.body.appendChild( renderer.domElement );\r\n\r\n  // L/W/H of the box - how far does a cube travel before resetting\r\n  const max = 8;\r\n\r\n  // Create standard box geometry\r\n  var geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );\r\n\r\n\r\n  var bb = new THREE.BoxGeometry(max*Math.E,max*Math.E,max*Math.E);\r\n  // var bb = new THREE.SphereGeometry(max*Math.E*2,max*Math.E,max*Math.E);\r\n  //var bb = new THREE.SphereGeometry();\r\n\r\n\r\nvar sphere = new THREE.SphereGeometry(max+0.25);\r\nvar object = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 }) );\r\nvar box = new THREE.BoxHelper( object );\r\nscene.add(box);\r\nscene.add(object);\r\n\r\nconst clock = new THREE.Clock();\r\n\r\n  // Create bounding box render\r\n  const bound = new THREE.BoxHelper(new THREE.Mesh(bb, new THREE.MeshBasicMaterial( 0xff0000 )), 0xffffff);\r\n\r\n  scene.add(bound);\r\n\r\n  const controls = new OrbitControls( camera, renderer.domElement );\r\n\r\n  camera.position.z = 15;\r\n\r\n\r\n  var dx = 0.05;\r\n  var dy = 0.05;\r\n  var dz = 0.05;\r\n\r\n  // scale_len = the length of any major or minor scale\r\n  //var scale_len = props.scaleRef.current.length;\r\n  //var max_speed = 0.002;\r\n\r\n  // Define base and max speed\r\n  // Then, generate a scalar up to max to multiply the base by\r\n  var max_mult = 5;\r\n  //var min_speed = props.speed;\r\n  \r\n  // Each note timing can range from 1-256\r\n  // This can be represented as a random power of 2 as\r\n  // 2**8 == 256 and 2**0 == 1\r\n  const max_note_len = 8;\r\n  // What is the maximum pitch notes can play at\r\n  const max_pitch = 4;\r\n  // What is the minimum pitch notes can play at\r\n  const min_pitch = 2;\r\n\r\n  // Notes can be represented by:\r\n  // n - regular note\r\n  // t - triplet\r\n  // n. - dotted note\r\n  // e.g. 4n. is a dotted quarter note\r\n  const note_types = ['n','t'];\r\n  \r\n\r\n  var cubes = [];\r\n\r\n  const reverb = new Tone.Reverb(2);\r\n  const delay = new Tone.PingPongDelay(\"8n\", 0.2);\r\n  const env = new Tone.Envelope(0.4);\r\n  const vibrato = new Tone.Vibrato();\r\n  const compressor = new Tone.Compressor(-30, 2);\r\n\r\n  env.attackCurve = 'sine';\r\n  //env.triggerAttack();\r\n\r\n  // for(var i = 0; i < props.numCubes; i++) {\r\n\r\n\r\n  //   const material = new THREE.MeshBasicMaterial( { \r\n  //     color: props.color(i) } );\r\n\r\n  //   const cube = new THREE.Mesh( geometry, material );\r\n  //   cubes[i] = cube;\r\n\r\n\r\n  //   // Random note, pitch and length generation\r\n  //   let randNote = Math.floor(Math.random() * scale_len);\r\n  //   let randPitch = Math.floor(Math.random() * max_pitch) + min_pitch;\r\n  //   let randLen = 2 ** Math.floor(Math.random() * max_note_len);\r\n  //   let type_idx = Math.floor(Math.random() * note_types.length);\r\n    \r\n  //   cubes[i].minSpeed = props.speedRef.current;\r\n\r\n  //   cubes[i].note = (props.scaleRef.current[randNote] + randPitch);\r\n\r\n  //   cubes[i].note_len = (randLen + note_types[type_idx]);\r\n\r\n  //   cubes[i].synth = new Tone.MembraneSynth();\r\n  //   //cubes[i].synth = new Tone.FMSynth();\r\n  //   //cubes[i].synth = new Tone.Synth();\r\n\r\n  //   //cubes[i].synth.chain(vibrato, reverb, compressor, Tone.Destination);\r\n  //   cubes[i].synth.chain(compressor, Tone.Destination);\r\n\r\n  //   // Define more random values :)\r\n  //   // Once the cube's counter reaches an arbitrary maximum, switch notes\r\n  //   cubes[i].counter = 0;\r\n\r\n  //   // How many times can a note repeat before changing\r\n  //   //cubes[i].max_repeats = (Math.ceil((Math.random() * 8))+1);\r\n  //   cubes[i].max_repeats = 6;\r\n\r\n  //   cubes[i].dx = cubes[i].minSpeed * (2**(Math.ceil((Math.random() * max_mult))+1));\r\n  //   cubes[i].dy = 0;\r\n  //   cubes[i].dz = 0;\r\n\r\n\r\n  //   const center = new THREE.Vector3();\r\n  //   cubes[i].dist = new THREE.Vector3(cubes[i].dx,cubes[i].dy,cubes[i].dz);\r\n\r\n  //   scene.add(cube);  \r\n\r\n  // }\r\n\r\n\r\n\r\n  return (\r\n    <>\r\n    <head>\r\n\r\n      <title>Snowy Scene</title>\r\n\r\n    </head>\r\n\r\n    <div className=\"App\">\r\n\r\n{/*        <Cube \r\n          color={colorC}\r\n          numCubes={numCubes}\r\n          tone={Tone}\r\n          scaleRef={scaleRef}\r\n          startRef={startRef}\r\n          speedRef={speedRef}\r\n\r\n        />\r\n\r\n        <Environment />*/}\r\n\r\n        <Legend \r\n          // onChange = {appOnChange()}\r\n          // modes={modes}\r\n          // mode={mode}\r\n          // note={note}\r\n          // setNote={setNote}\r\n          // notes={notes}\r\n          // setMode={setMode}\r\n          // speedRef={speedRef}\r\n          // rangeRef={rangeRef}\r\n          // setNote={setNote}\r\n          // initAudio={initAudio}\r\n          // startRef={startRef}\r\n\r\n          />\r\n\r\n    </div>\r\n\r\n    </>\r\n  );\r\n}\r\n\r\nexport default App;"]},"metadata":{},"sourceType":"module"}